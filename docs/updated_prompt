# Network Monitoring Application

Create a self-hosted network monitoring web application that tests host availability and displays performance metrics.

## Tech Stack
- **Backend**: Ruby 3.3+ with Sinatra 4.x
- **Database**: SQLite3 with Sequel ORM
- **Server**: Puma
- **Frontend**: ERB templates, vanilla JavaScript, Chart.js
- **Scheduler**: rufus-scheduler for background tasks
- **Deployment**: Docker with docker-compose

## Core Features

### 1. Host Management
- CRUD operations for network hosts (name, IP/hostname, enabled status)
- Multiple test types per host:
  - **Ping (ICMP)**: Single ping, latency only
  - **TCP**: Port connectivity, latency
  - **HTTP/HTTPS**: Endpoint monitoring with status codes
  - **DNS**: Resolution testing
  - **Jitter**: Optional IPDV calculation (RFC 3393) using 5 pings with 0.2s interval
- Randomness setting (0-50%) to vary test timing
- Per-host jitter toggle independent from ping latency

### 2. Automated Testing
- Background scheduler at configurable intervals (default: 5 min)
- Per-test scheduling with independent `next_test_at` timestamps
- Variability factor recalculated each test (e.g., 5% on 5min = ±15s)
- **Race Condition Prevention**: Atomic claim pattern—update `next_test_at` with WHERE clause before running, skip if another worker claimed
- **Outlier Detection**:
  - Flags results 10× worse than baseline AND >500ms difference
  - Baseline from last 50 measurements per test type (minimum 5 required)
  - Auto-retests outliers; records retest if normal, original if confirmed
  - Uses `record_results: false` for retests to prevent loops

### 3. Dashboard & Visualization
- Real-time status overview with color-coded indicators
- **Rolling Window Statistics**: Last 50 measurements per test type (independent windows)
- Charts via Chart.js: latency trends, jitter trends, reachability
- Time range selector: 1h, 6h, 24h, 7d, 30d, custom
- Statistics independent of time range (rolling vs historical)

### 4. Settings
- Test intervals and timeouts per type (HTTP: 10s, TCP/Ping/DNS: 5s)
- Data retention periods (raw: 14d, 15min aggregates: 30d, hourly: 1 year)
- Theme selection (3+ dark, 3+ light themes via YAML)
- Outlier detection toggles and thresholds

### 5. Data Model
- **hosts**: id, name, address, enabled, randomness_percent, jitter_enabled, timestamps
- **tests**: id, host_id, test_type, enabled, port, http_scheme, dns_query_hostname, next_test_at, timestamps
- **measurements**: id, host_id, test_type, tested_at, reachable, latency_ms, jitter_ms, http_status, error
- **measurements_15min/hourly**: id, host_id, test_type, period_start/end, test_count, success_count, avg/min/max_latency_ms, avg_jitter_ms
- **settings**: key, value, timestamps

## Implementation Requirements

### Project Structure
```
app/models/          # Sequel models
app/routes/          # Sinatra route files
app/views/           # ERB templates
bin/                 # Helper scripts (console, setup, server, test)
config/              # Application and database config
db/migrations/       # Sequel migrations
lib/checker/testers/ # Test implementations
lib/checker/         # Scheduler, aggregator, logger
test/                # Minitest suite
themes/              # YAML theme definitions
public/              # Static assets
```

### Security Requirements
- **Command Injection Prevention**: Use `Shellwords.shellescape` for any shell commands (ping addresses)
- **Resource Cleanup**: Socket operations must use `ensure` blocks for cleanup
- **Input Validation**: Validate addresses, ports, test types in models

### API Endpoints
- `GET/POST/PUT/DELETE /api/hosts` - Host CRUD with nested tests
- `GET /api/hosts/:id/stats` - Rolling window statistics
- `GET /api/measurements/host/:id` - Measurements with time range
- `POST /api/tests/:id/run` - Trigger single test
- `POST /api/hosts/:id/run` - Trigger all tests for host
- `GET/PUT /api/settings` - Settings management
- `GET /health` - Health check

### Test Implementation Pattern
```ruby
class BaseTester
  def test
    result = perform_test
    result = handle_outlier_detection(result) if should_record?
    record_result(result) if should_record?
    result
  end
end
```
Return format: `{reachable: bool, latency_ms: float, jitter_ms: float|nil, http_status: int|nil, error: string|nil}`

### Scheduler Pattern
```ruby
# Atomic claim to prevent race conditions
claimed = Test.where(id: test.id)
  .where { Sequel.|({ next_test_at: nil }, Sequel.expr(next_test_at) <= now) }
  .update(next_test_at: next_time)
next if claimed.zero?
# Now safe to run test
```

### Configuration Pattern
Centralize timeout configs in one place:
```ruby
def test_config
  { ping_count: 5, ping_timeout: 5, tcp_timeout: 5, http_timeout: 10, dns_timeout: 5 }
end
```

### Aggregation
- Group by `[host_id, test_type, period]` not just `[host_id, period]`
- 15-min aggregates from raw data older than retention
- Hourly aggregates from 15-min data older than retention
- Cleanup hourly data older than 1 year

### Docker Setup
- Multi-stage Dockerfile using `ruby:3.3-slim` (not Alpine—musl/glibc issues with sqlite3)
- Requires `NET_RAW` capability for ICMP
- Data persistence via `/data` volume
- Non-root user (checker, UID 1000)

### Rake Tasks
- `db:migrate` - Run migrations
- `db:rollback` - Rollback one migration (use `applied_migrations` to get current version, not `run()`)
- `db:seed` - Sample data
- `test` - Run Minitest suite

## Constraints
- Keep dependencies minimal (Sinatra, not Rails)
- All testers complete within timeout periods
- Handle concurrent scheduler and API access
- Use RuboCop with sensible defaults (line length 120, exclude migrations)

## Data Lifecycle
1. Raw → 14 days → aggregated to 15-min
2. 15-min → 30 days → aggregated to hourly
3. Hourly → 1 year → deleted
4. Steady-state: ~50MB for 10 tests running continuously

Create a working application with migrations, seed data, and comprehensive README.
