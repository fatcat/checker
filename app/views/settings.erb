<div class="settings-page">
  <h1>Settings</h1>

  <nav class="settings-nav">
    <div class="settings-nav-links">
      <a href="#appearance">Appearance</a>
      <a href="#logging">Logging</a>
      <a href="#testing">Testing</a>
      <a href="#outlier">Outlier Detection</a>
      <a href="#retention">Data Retention</a>
    </div>
    <div class="settings-nav-actions">
      <button type="submit" form="settings-form" class="btn btn-primary btn-sm">Save</button>
      <button type="button" class="btn btn-secondary btn-sm" onclick="Settings.loadSettings()">Discard Changes</button>
    </div>
  </nav>

  <form id="settings-form" class="settings-form">
    <section class="settings-section" id="appearance">
      <h2>Appearance</h2>

      <div class="form-group">
        <label for="theme">Theme</label>
        <select id="theme">
          <optgroup label="Dark Themes" id="dark-themes"></optgroup>
          <optgroup label="Light Themes" id="light-themes"></optgroup>
        </select>
        <small class="form-hint">Choose your preferred color theme. Custom themes can be added as JSON files in the themes directory.</small>
      </div>

      <div class="theme-preview" id="theme-preview">
        <div class="preview-header">Theme Preview</div>
        <div class="preview-content">
          <div class="preview-surface">
            <span class="preview-text">Sample text</span>
            <span class="preview-muted">Muted text</span>
          </div>
          <div class="preview-badges">
            <span class="preview-badge accent">Accent</span>
            <span class="preview-badge success">Success</span>
            <span class="preview-badge warning">Warning</span>
            <span class="preview-badge danger">Danger</span>
          </div>
        </div>
      </div>
    </section>

    <section class="settings-section" id="logging">
      <h2>Logging</h2>

      <div class="form-group">
        <label for="log_rotation_period">Log Rotation Period</label>
        <select id="log_rotation_period">
          <option value="hourly">Hourly</option>
          <option value="daily">Daily</option>
        </select>
        <small class="form-hint">How often to rotate log files</small>
      </div>

      <div class="form-group">
        <label for="log_retention_count">Log Files to Retain</label>
        <input type="number" id="log_retention_count" min="1" max="168">
        <small class="form-hint">Number of log files to keep (max 168). For hourly rotation, 12 = 12 hours. For daily, 7 = 1 week.</small>
      </div>
    </section>

    <section class="settings-section" id="testing">
      <h2>Testing</h2>

      <div class="form-group">
        <label for="test_interval_seconds">Test Interval (seconds)</label>
        <input type="number" id="test_interval_seconds" min="60" max="3600">
        <small class="form-hint">How often to run tests. Minimum: 60 seconds (1 minute)</small>
      </div>

      <div class="form-group">
        <label for="http_timeout_seconds">HTTP Timeout (seconds)</label>
        <input type="number" id="http_timeout_seconds" min="1" max="60">
        <small class="form-hint">Timeout for HTTP health checks</small>
      </div>

      <div class="form-group">
        <label for="tcp_timeout_seconds">TCP Timeout (seconds)</label>
        <input type="number" id="tcp_timeout_seconds" min="1" max="60">
        <small class="form-hint">Timeout for TCP port checks</small>
      </div>

      <div class="form-group">
        <label for="dns_timeout_seconds">DNS Timeout (seconds)</label>
        <input type="number" id="dns_timeout_seconds" min="1" max="60">
        <small class="form-hint">Timeout for DNS resolution tests</small>
      </div>

      <div class="form-group">
        <label for="ping_count">Ping Count</label>
        <input type="number" id="ping_count" min="1" max="20">
        <small class="form-hint">Number of pings to send for jitter calculation</small>
      </div>

      <div class="form-group">
        <label for="ping_timeout_seconds">Ping Timeout (seconds)</label>
        <input type="number" id="ping_timeout_seconds" min="1" max="30">
        <small class="form-hint">Timeout for ping tests</small>
      </div>
    </section>

    <section class="settings-section" id="outlier">
      <h2>Outlier Detection</h2>

      <div class="form-group toggle-group">
        <label class="toggle-row" for="outlier_detection_enabled">
          <span class="toggle-label">Enable Outlier Detection</span>
          <span class="toggle-switch">
            <input type="checkbox" id="outlier_detection_enabled">
            <span class="toggle-slider"></span>
          </span>
        </label>
        <small class="form-hint">Automatically retest when a result appears to be an outlier. If retest shows normal values, the outlier is discarded.</small>
      </div>

      <div class="form-group">
        <label for="outlier_threshold_multiplier">Threshold Multiplier</label>
        <input type="number" id="outlier_threshold_multiplier" min="2" max="20" step="1">
        <small class="form-hint">A result must exceed the baseline median × this multiplier to be flagged as an outlier (default: 5×)</small>
      </div>

      <div class="outlier-info">
        <strong>How it works:</strong>
        A result is flagged as a potential outlier when it exceeds the baseline median × multiplier.
        The median is calculated from the last 50 measurements for each host and test type combination, making it robust against existing outliers and tailored to each host's typical performance.
        When flagged, the test is immediately re-run. If the retest shows normal values, the outlier reading is discarded. If the retest confirms the issue, the original result is recorded.
      </div>
    </section>

    <section class="settings-section" id="retention">
      <h2>Data Retention</h2>

      <div class="form-group">
        <label for="raw_data_retention_days">Raw Data Retention (days)</label>
        <input type="number" id="raw_data_retention_days" min="1" max="365">
        <small class="form-hint">How long to keep detailed measurement data</small>
      </div>

      <div class="form-group">
        <label for="aggregation_15min_retention_days">15-Minute Aggregation Retention (days)</label>
        <input type="number" id="aggregation_15min_retention_days" min="1" max="365">
        <small class="form-hint">How long to keep 15-minute aggregated data before converting to hourly</small>
      </div>

      <div class="retention-info">
        <strong>Data Lifecycle:</strong>
        <ul>
          <li><strong>Raw measurements</strong> - Kept for the configured number of days, then aggregated to 15-minute intervals</li>
          <li><strong>15-minute aggregates</strong> - Kept for the configured number of days, then aggregated to hourly intervals</li>
          <li><strong>Hourly aggregates</strong> - Kept for 1 year maximum. Database size with 10 tests running continuously: approximately 50 MB after one year.</li>
        </ul>
      </div>
    </section>
  </form>
</div>

<style>
html {
  scroll-behavior: smooth;
}

.settings-nav {
  position: sticky;
  top: 0;
  z-index: 10;
  background-color: var(--color-background);
  padding: 0.75rem 0;
  margin-bottom: 1.5rem;
  border-bottom: 1px solid var(--color-border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
  flex-wrap: wrap;
}

.settings-nav-links {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.settings-nav-actions {
  display: flex;
  gap: 0.5rem;
}

.btn-sm {
  padding: 0.35rem 0.75rem;
  font-size: 0.85rem;
}

.settings-nav-actions .btn:disabled {
  opacity: 0.35;
  cursor: not-allowed;
  background-color: var(--color-border);
}

.settings-nav a {
  padding: 0.4rem 0.8rem;
  border-radius: var(--border-radius);
  color: var(--color-text-muted);
  text-decoration: none;
  font-size: 0.9rem;
  transition: background-color 0.2s, color 0.2s;
}

.settings-nav a:hover {
  background-color: var(--color-surface);
  color: var(--color-text);
}

.settings-nav a.active {
  background-color: var(--color-accent);
  color: white;
}

.settings-form {
  max-width: 700px;
}

.settings-section {
  margin-bottom: 2.5rem;
  padding-bottom: 1.5rem;
  border-bottom: 1px solid var(--color-border);
  scroll-margin-top: 60px;
}

.settings-section:last-of-type {
  border-bottom: none;
}

.settings-section h2 {
  font-size: 1.25rem;
  margin-bottom: 1.25rem;
  color: var(--color-text);
}

.form-hint {
  display: block;
  color: var(--color-text-muted);
  font-size: 0.85rem;
  margin-top: 0.25rem;
}

.theme-preview {
  margin-top: 1rem;
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius);
  overflow: hidden;
}

.preview-header {
  padding: 0.5rem 1rem;
  font-size: 0.85rem;
  font-weight: 500;
  border-bottom: 1px solid var(--color-border);
}

.preview-content {
  padding: 1rem;
}

.preview-surface {
  padding: 1rem;
  border-radius: 4px;
  margin-bottom: 1rem;
}

.preview-text {
  display: block;
  margin-bottom: 0.25rem;
}

.preview-muted {
  display: block;
  font-size: 0.85rem;
}

.preview-badges {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.preview-badge {
  padding: 0.25rem 0.75rem;
  border-radius: 4px;
  font-size: 0.85rem;
  font-weight: 500;
}

.preview-badge.accent {
  background-color: var(--preview-accent);
  color: white;
}

.preview-badge.success {
  background-color: var(--preview-success);
  color: white;
}

.preview-badge.warning {
  background-color: var(--preview-warning);
  color: black;
}

.preview-badge.danger {
  background-color: var(--preview-danger);
  color: white;
}

.retention-info {
  margin-top: 1.5rem;
  padding: 1rem;
  background-color: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius);
  font-size: 0.9rem;
}

.retention-info strong {
  color: var(--color-text);
}

.retention-info ul {
  margin: 0.75rem 0 0 0;
  padding-left: 1.5rem;
  color: var(--color-text-muted);
}

.retention-info li {
  margin-bottom: 0.5rem;
}

.retention-info li:last-child {
  margin-bottom: 0;
}

.outlier-info {
  margin-top: 1.5rem;
  padding: 1rem;
  background-color: var(--color-surface);
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius);
  font-size: 0.9rem;
}

.outlier-info strong {
  color: var(--color-text);
}

.outlier-info ul {
  margin: 0.75rem 0 0 0;
  padding-left: 1.5rem;
  color: var(--color-text-muted);
}

.outlier-info li {
  margin-bottom: 0.5rem;
}

.outlier-info li:last-child {
  margin-bottom: 0;
}

.form-group label input[type="checkbox"] {
  margin-right: 0.5rem;
  vertical-align: middle;
}

/* Toggle switch styles */
.toggle-group {
  margin-bottom: 1rem;
}

.toggle-row {
  display: flex !important;
  align-items: center;
  gap: 1rem;
  cursor: pointer;
  margin-bottom: 0.5rem;
}

.toggle-row .toggle-label {
  font-weight: 500;
  color: var(--color-text);
  background: transparent !important;
  background-color: transparent !important;
  border: none !important;
  border-radius: 0 !important;
  padding: 0 !important;
  margin: 0;
  display: inline;
  font-size: 1rem;
  line-height: 1.5;
  box-shadow: none !important;
}

span.toggle-switch {
  position: relative;
  display: inline-block;
  width: 48px;
  height: 26px;
  flex-shrink: 0;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.toggle-slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: var(--color-border);
  transition: 0.3s;
  border-radius: 26px;
}

.toggle-slider:before {
  position: absolute;
  content: "";
  height: 20px;
  width: 20px;
  left: 3px;
  bottom: 3px;
  background-color: var(--color-background);
  transition: 0.3s;
  border-radius: 50%;
}

.toggle-switch input:checked + .toggle-slider {
  background-color: var(--color-success);
}

.toggle-switch input:checked + .toggle-slider:before {
  transform: translateX(22px);
}

.toggle-switch input:focus + .toggle-slider {
  box-shadow: 0 0 0 2px var(--color-accent);
}
</style>

<script>
const Settings = {
  settings: {},
  themes: [],
  hasChanges: false,

  init() {
    this.loadThemes();
    this.loadSettings();
    this.setupNavHighlighting();
    this.setupChangeTracking();
    document.getElementById('settings-form').addEventListener('submit', (e) => this.saveSettings(e));
    document.getElementById('theme').addEventListener('change', (e) => this.previewTheme(e.target.value));
  },

  setupChangeTracking() {
    const form = document.getElementById('settings-form');
    form.addEventListener('change', () => this.markChanged());
    form.addEventListener('input', () => this.markChanged());
    this.updateSaveButton();
  },

  markChanged() {
    this.hasChanges = true;
    this.updateSaveButton();
  },

  updateSaveButton() {
    const saveBtn = document.querySelector('.settings-nav-actions button[type="submit"]');
    if (saveBtn) {
      saveBtn.disabled = !this.hasChanges;
    }
  },

  setupNavHighlighting() {
    const sections = document.querySelectorAll('.settings-section[id]');
    const navLinks = document.querySelectorAll('.settings-nav a');

    const updateActiveSection = () => {
      const scrollPos = window.scrollY + 80; // offset for sticky nav

      // Check if at bottom first
      const scrolledToBottom = (window.innerHeight + window.scrollY) >= (document.body.offsetHeight - 50);
      if (scrolledToBottom) {
        navLinks.forEach(link => link.classList.remove('active'));
        navLinks[navLinks.length - 1].classList.add('active');
        return;
      }

      // Find which section we're in (last section whose top is above scroll position)
      let currentSection = sections[0];
      sections.forEach(section => {
        if (section.offsetTop <= scrollPos) {
          currentSection = section;
        }
      });

      navLinks.forEach(link => link.classList.remove('active'));
      const activeLink = document.querySelector(`.settings-nav a[href="#${currentSection.id}"]`);
      if (activeLink) activeLink.classList.add('active');
    };

    window.addEventListener('scroll', updateActiveSection);
    updateActiveSection(); // Initial highlight
  },

  async loadThemes() {
    try {
      const response = await fetch('/api/themes');
      const data = await response.json();
      this.themes = data.themes;

      const darkGroup = document.getElementById('dark-themes');
      const lightGroup = document.getElementById('light-themes');

      data.dark_themes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme.id;
        option.textContent = theme.name;
        darkGroup.appendChild(option);
      });

      data.light_themes.forEach(theme => {
        const option = document.createElement('option');
        option.value = theme.id;
        option.textContent = theme.name;
        lightGroup.appendChild(option);
      });
    } catch (error) {
      console.error('Failed to load themes:', error);
    }
  },

  async loadSettings() {
    try {
      const response = await fetch('/api/settings');
      const data = await response.json();
      this.settings = data.settings;
      this.populateForm();
    } catch (error) {
      console.error('Failed to load settings:', error);
      alert('Failed to load settings');
    }
  },

  populateForm() {
    const fields = [
      'test_interval_seconds',
      'raw_data_retention_days',
      'aggregation_15min_retention_days',
      'http_timeout_seconds',
      'tcp_timeout_seconds',
      'dns_timeout_seconds',
      'ping_count',
      'ping_timeout_seconds',
      'log_rotation_period',
      'log_retention_count',
      'theme',
      'outlier_threshold_multiplier'
    ];

    fields.forEach(field => {
      const input = document.getElementById(field);
      if (input && this.settings[field] !== undefined) {
        input.value = this.settings[field];
      }
    });

    // Handle checkbox for outlier detection
    const outlierCheckbox = document.getElementById('outlier_detection_enabled');
    if (outlierCheckbox && this.settings.outlier_detection_enabled !== undefined) {
      outlierCheckbox.checked = this.settings.outlier_detection_enabled === 'true' || this.settings.outlier_detection_enabled === true;
    }

    // Update theme preview
    if (this.settings.theme) {
      this.previewTheme(this.settings.theme);
    }

    // Reset change tracking after populating
    this.hasChanges = false;
    this.updateSaveButton();
  },

  async previewTheme(themeId) {
    const preview = document.getElementById('theme-preview');
    const theme = this.themes.find(t => t.id === themeId);

    if (!theme) return;

    try {
      const response = await fetch(`/api/themes/${themeId}/css`);
      const css = await response.text();

      // Parse CSS variables from response
      const vars = {};
      const matches = css.matchAll(/--color-([^:]+):\s*([^;]+);/g);
      for (const match of matches) {
        vars[match[1]] = match[2].trim();
      }

      // Apply to preview
      preview.style.setProperty('--preview-bg', vars['background']);
      preview.style.setProperty('--preview-surface', vars['surface']);
      preview.style.setProperty('--preview-border', vars['border']);
      preview.style.setProperty('--preview-text', vars['text']);
      preview.style.setProperty('--preview-muted', vars['text-muted']);
      preview.style.setProperty('--preview-accent', vars['accent']);
      preview.style.setProperty('--preview-success', vars['success']);
      preview.style.setProperty('--preview-warning', vars['warning']);
      preview.style.setProperty('--preview-danger', vars['danger']);

      preview.querySelector('.preview-header').style.backgroundColor = vars['background'];
      preview.querySelector('.preview-header').style.color = vars['text-muted'];
      preview.querySelector('.preview-content').style.backgroundColor = vars['background'];
      preview.querySelector('.preview-surface').style.backgroundColor = vars['surface'];
      preview.querySelector('.preview-text').style.color = vars['text'];
      preview.querySelector('.preview-muted').style.color = vars['text-muted'];

    } catch (error) {
      console.error('Failed to preview theme:', error);
    }
  },

  async saveSettings(e) {
    e.preventDefault();

    const data = {
      test_interval_seconds: document.getElementById('test_interval_seconds').value,
      raw_data_retention_days: document.getElementById('raw_data_retention_days').value,
      aggregation_15min_retention_days: document.getElementById('aggregation_15min_retention_days').value,
      http_timeout_seconds: document.getElementById('http_timeout_seconds').value,
      tcp_timeout_seconds: document.getElementById('tcp_timeout_seconds').value,
      dns_timeout_seconds: document.getElementById('dns_timeout_seconds').value,
      ping_count: document.getElementById('ping_count').value,
      ping_timeout_seconds: document.getElementById('ping_timeout_seconds').value,
      log_rotation_period: document.getElementById('log_rotation_period').value,
      log_retention_count: document.getElementById('log_retention_count').value,
      theme: document.getElementById('theme').value,
      outlier_detection_enabled: document.getElementById('outlier_detection_enabled').checked,
      outlier_threshold_multiplier: document.getElementById('outlier_threshold_multiplier').value
    };

    try {
      const response = await fetch('/api/settings', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data)
      });

      if (response.ok) {
        const result = await response.json();
        this.settings = result.settings;

        // Apply theme immediately using global ThemeManager
        if (window.ThemeManager) {
          window.ThemeManager.applyTheme(data.theme);
        }

        // Reset change tracking
        this.hasChanges = false;
        this.updateSaveButton();

        alert('Settings saved successfully');
      } else {
        alert('Failed to save settings');
      }
    } catch (error) {
      console.error('Failed to save settings:', error);
      alert('Failed to save settings');
    }
  }
};

document.addEventListener('DOMContentLoaded', () => Settings.init());
</script>
